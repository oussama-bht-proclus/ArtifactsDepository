pipeline {
	agent any

	//Configure the following environment variables before executing the Jenkins Job	
	environment {
		IntegrationFlowID = "Access_Secure_Parameters_in_Scripts"
		CPIHost = "5f8ab36dtrial.it-cpitrial06.cfapps.us10-001.hana.ondemand.com"
		CPIOAuthHost = "5f8ab36dtrial.authentication.us10.hana.ondemand.com"
		CPIOAuthCredentials = "${env.CPI_OAUTH_CRED}"	
		GITRepositoryURL  = "github.com/oussama-bht-proclus/ArtifactsDepository.git"
		GITRepositoryURLSSH = "https://github.com/oussama-bht-proclus/ArtifactsDepository.git"
		//GITCredentials = "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"
		GITCredentials = "GithubCReds"
		GIT_CREDENTIALS_ID = "SSHPrivate"
		GITBranch = "main"
		GITFolder = "IntegrationContent/IntegrationArtefacts"
		GITComment = "Integration Artefacts update from CICD pipeline"
   	}

	
	
	stages {
		stage('download integration artefact and store it in Git') {
			steps {
			 	deleteDir()
				script {
					//clone repo 
					checkout([
						$class: 'GitSCM',
						branches: [[name: env.GITBranch]],
						doGenerateSubmoduleConfigurations: false,
						extensions: [
							[$class: 'RelativeTargetDirectory',relativeTargetDir: "."],
							[$class: 'SparseCheckoutPaths',  sparseCheckoutPaths:[[$class:'SparseCheckoutPath', path: env.GITFolder]]]
						],
						submoduleCfg: [],
						userRemoteConfigs: [[
							credentialsId: env.GITCredentials,
							url: 'https://' + env.GITRepositoryURL
						]]
					])
					
					//get token
					println("Request token");
					def token;
					try{
						println('REQUEST BEFORE')
						def getTokenResp = httpRequest acceptType: 'APPLICATION_JSON', 
							//authentication: env.CPIOAuthCredentials, 
							customHeaders : [[name: 'Authorization', value: "Basic c2ItNWQ3NTA0ZTUtYzJkMS00NGRkLTkzMDctZWFiNDM1YzBiOWJiIWIyODQ1MDN8aXQhYjU1MjE1OmQ0ODkwMzUxLTE1NWEtNDM4YS1hZmMxLTdkOTFhNTRlNjUzZiRLaEZ0aGFSVnNzcW90cjlQS0tuY1JWZDNkME9YSTZONHRzWmV2X0gtX1ZFPQ=="]],
							contentType: 'APPLICATION_JSON', 
							httpMode: 'POST', 
							responseHandle: 'LEAVE_OPEN', 
							timeout: 30, 
							url: 'https://' + env.CPIOAuthHost + '/oauth/token?grant_type=client_credentials';
						println('REQUEST BEFORE json')
						def jsonObjToken = readJSON text: getTokenResp.getContent()
						println('REQUEST AFTER')
						token = "Bearer " + jsonObjToken.access_token
				   	} catch (Exception e) {
						error("Requesting the oauth token for Cloud Integration failed:\n${e}")
					}
					//delete the old flow content so that only the latest content gets stored
					dir(env.GITFolder + '/' + env.IntegrationFlowID){
						deleteDir();
					}
					//download and extract artefact from tenant
					println("Downloading artefact");
					def tempfile = UUID.randomUUID().toString() + ".zip";
					def cpiDownloadResponse = httpRequest acceptType: 'APPLICATION_ZIP', 
						customHeaders: [[maskValue: false, name: 'Authorization', value: token]], 
						ignoreSslErrors: false, 
						responseHandle: 'LEAVE_OPEN', 
						validResponseCodes: '100:399, 404',
						timeout: 30,  
						outputFile: tempfile,
						url: 'https://' + env.CPIHost + '/api/v1/IntegrationDesigntimeArtifacts(Id=\''+ env.IntegrationFlowID + '\',Version=\'active\')/$value';
					if (cpiDownloadResponse.status == 404){
						//invalid Flow ID
						error("Received http status code 404. Please check if the Artefact ID that you have provided exists on the tenant.");
					}

					def disposition = cpiDownloadResponse.headers.toString();
					def index=disposition.indexOf('filename')+9;
					def lastindex=disposition.indexOf('.zip', index);
					def filename=disposition.substring(index + 1, lastindex + 4);
					def folder=env.GITFolder + '/' + filename.substring(0, filename.indexOf('.zip'));

					try {
						fileOperations([fileUnZipOperation(filePath: tempfile, targetLocation: folder)])
					}catch(Exception excep){
						println("EXCEPTIOn =>");
						println(excep.getMessage());
					}

					cpiDownloadResponse.close();

					//remove the zip
					fileOperations([fileDeleteOperation(excludes: '', includes: tempfile)])
						
					dir(folder){
						sh 'git add .'
					}
					println("Store integration artefact in Git")

					/*
					withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: env.GITCredentials ,usernameVariable: 'GIT_AUTHOR_NAME', passwordVariable: 'GIT_PASSWORD']]) {  
						sh 'git diff-index --quiet HEAD || git commit -am ' + '\'' + env.GitComment + '\''
						sh('git push https://${GIT_AUTHOR_NAME}:${GIT_PASSWORD}@' + env.GITRepositoryURL + ' HEAD:' + env.GITBranch)
					}
					*/

					try {
						/*withCredentials([sshUserPrivateKey(credentialsId: 'TRIAL_SSH', keyFileVariable: 'SSH_KEY_PATH')]) {
							script {
								sh '''
								eval `ssh-agent -s`
								ssh-add $SSH_KEY_PATH
								'''
								sh 'git config core.sshCommand "ssh -i $SSH_KEY_PATH -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"'
								sh 'git diff-index --quiet HEAD || git commit -am "' + env.GITComment + '"'
								sh 'git push ' + env.GITRepositoryURL + ' HEAD:' + env.GITBranch
							}
						}
						*/
						// Retrieve SSH key and passphrase from Jenkins credentials
                        withCredentials([sshUserPrivateKey(credentialsId: 'TRIAL_SSH', keyFileVariable: 'SSH_KEY_PATH', passphraseVariable: 'SSH_PASSPHRASE')]) {
                            // Start SSH agent and add the key
                            sh '''
                                eval `ssh-agent -s`
                                echo "$SSH_PASSPHRASE" | ssh-add $SSH_KEY_PATH
                            '''
                            
                            // Configure git to use SSH key
                            sh 'git config core.sshCommand "ssh -i $SSH_KEY_PATH -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"'

                            // Commit and push changes
                            sh 'git diff-index --quiet HEAD || git commit -am "' + env.GITComment + '"'
                            sh 'git push ' + env.GITRepositoryURLSSH + ' HEAD:' + env.GITBranch
                        }
					} catch(Exception exception){
						println('EXCEPTION CATCHED')
                        println("Error: ${e.getMessage()}")
					}

					/*
					try {
                        // Retrieve SSH key and passphrase from Jenkins credentials
                        withCredentials([sshUserPrivateKey(credentialsId: 'TRIAL_SSH', keyFileVariable: 'SSH_KEY_PATH', passphraseVariable: 'SSH_PASSPHRASE')]) {
                            // Start SSH agent and add the key
                            sh '''
                                eval $(ssh-agent -s)
                                ssh-add $SSH_KEY_PATH < <(echo $SSH_PASSPHRASE)
                            '''
                            
                            // Configure git to use SSH key
                            sh 'git config core.sshCommand "ssh -i $SSH_KEY_PATH -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"'

                            // Commit and push changes
                            sh 'git diff-index --quiet HEAD || git commit -am "' + env.GITComment + '"'
                            sh 'git push ' + env.GITRepositoryURL + ' HEAD:' + env.GITBranch
                        }
                    } catch (Exception e) {

                        // Capture and print any exceptions
						
                        //currentBuild.result = 'FAILURE'

                    }*/

					println('PIPELINE OVER')				
				}
			}
		}
    }
}
